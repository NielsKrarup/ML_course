# -*- coding: utf-8 -*-
"""HA2_reg.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WYIZu8p5250p4ohJiPJpH5u8-JcTBciq
"""

import os
import numpy as np


# Get the current working directory
current_directory = os.getcwd()

# Print the current working directory
print("Current working directory:", current_directory)

"""Read in data"""

data = np.loadtxt(f"drive/MyDrive/ML_course/data/PCB.dt")
print(data)
data
x = data[:,0]
y = data[:,1]

import numpy as np

def linear_reg(x,y):
  if len(x.shape) == 0: raise ValueError('Need covariates!!')
  elif len(x.shape) == 1:
    n = x.shape[0] #take nrow
    d = 1 #num covariates
    X = np.ones((n,2)) #fill out ones. for replacement later
    X[:,0] = x #first col
  else:
    n, d = x.shape #d > 1
    X = np.ones((n, d+1))
    X[:, :d] = x
  pseudo_inv_X = np.matmul( np.linalg.inv( np.matmul(X.T, X)), X.T) #(XTX)^-1 XT
  reg_fit = np.matmul(pseudo_inv_X, y)
  w = reg_fit[:d]
  b = reg_fit[d:]
  return w,b

print(linear_reg(x=data[:,0], y=data[:,1]))
w, b_lin = linear_reg(x=data[:,0], y=data[:,1])

"""transformed endpoints

"""

def nonlinear_reg(x,y):
  if len(x.shape) == 0: raise ValueError('Need covariates!!')
  elif len(x.shape) == 1:
    n = x.shape[0] #take nrow
    d = 1 #num covariates
    X = np.ones((n,2)) #fill out ones. for replacement later
    X[:,0] = x #first col
  else:
    n, d = x.shape #d > 1
    X = np.ones((n, d+1))
    X[:, :d] = x
  y_trans = np.log(y)
  pseudo_inv_X = np.matmul( np.linalg.inv( np.matmul(X.T, X)), X.T) #(XTX)^-1 XT
  reg_fit = np.matmul(pseudo_inv_X, y_trans)
  a = reg_fit[:d]
  b = reg_fit[d:]
  mse = np.mean((y - np.exp(a*x + b))**2)
  return a,b, mse

print(nonlinear_reg(x=data[:,0], y=data[:,1]))
a, b_non_lin, mse = nonlinear_reg(x=data[:,0], y=data[:,1])

"""plotting

"""

import matplotlib.pyplot as plt

# evenly sampled time at 200ms intervals
t = np.arange(0., 15, 0.2)
8*w[0]
# red dashes, blue squares and green triangles
plt.scatter(data[:,0], data[:,1], label = "data")

plt.plot(t, t*w[0] + b_lin[0], 'r-')

plt.plot(t, np.exp(t*a[0] + b_non_lin[0]), 'b-')



plt.show()